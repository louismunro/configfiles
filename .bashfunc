bak () {
    cp -i $1 ${1}.`date +%y%m%d`
}

cstream () {
    perl -p -e "s/$1/\e[31m$&\e[0m/i"
}

penv () {
    # get the environment for a pid
    cat /proc/$1/environ | tr '\0' '\n' 
}

function lc {
    tr [[:upper:]] [[:lower:]] < /dev/stdin 
} 

function uc {
    tr [[:lower:]] [[:upper:]] < /dev/stdin 
} 

function parse_git_dirty {
 git diff --no-ext-diff --quiet --exit-code &> /dev/null || echo "*"
}

function parse_git_branch {
  git branch --no-color 2> /dev/null | sed -e '/^[^*]/d' -e "s/* \(.*\)/(\1$(parse_git_dirty))/"
}

function ssh { 
    if [[ -z "$SSH_AGENT_PID" ]] ; then 
        eval `ssh-agent`
        ssh-add
    fi
    command ssh "$@"
}

__kube_ps1()
{
    # Get current context
    CONTEXT=$(kubectl config current-context 2>/dev/null)

    if [ -n "$CONTEXT" ]; then
        echo "(k8s: ${CONTEXT})"
    fi
}

function aws_account_info {
  [ "$AWS_ACCOUNT_NAME" ] && [ "$AWS_ACCOUNT_ROLE" ] && echo -n "aws:($AWS_ACCOUNT_NAME:$AWS_ACCOUNT_ROLE) "
}

function json2yaml { 
   ruby -ryaml -rjson -e 'puts YAML.dump(JSON.parse(STDIN.read))' <  $1
}

function yaml2json {
  ruby -ryaml -rjson -e 'puts YAML.load_file(ARGV[0]).to_json'  $1
}

function kcrash { 
    local match
    match=${1:-.}
    kubectl get pods -owide  | grep $match |
            perl -wanl -e  '( $. == 1 
                            || ( eval($F[1]) != 1 && $F[2] !~ /Completed/ )
                            ) && print'
} 
export -f kcrash >/dev/null

# roule une commande sur chacune des nodes
krun() {
  for k in $(kubectl get nodes -o jsonpath='{.items[*].metadata.name}' ) ; do 
    echo -n "$k :" ; ssh $k $@
  done
}

# alias kpods='kubectl get pods -owide'
function kpods {
    local match
    match=${1:-.}
    kubectl get pods -owide | grep $match
}

function goplay {
  # requires github.com/wrouesnel/go-play
  pushd $GOPATH/src/github.com/wrouesnel/go-play/goplay
  make run
  popd
}
export -f goplay >/dev/null


